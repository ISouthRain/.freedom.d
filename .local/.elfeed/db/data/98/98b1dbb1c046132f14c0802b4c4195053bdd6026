<p data-pid="heSssC_0"><b>写在前面</b>：在不久前的一篇文章中，我们简单聊了聊如何使用 Taichi 加速 Python 程序。文章发布后，不少从事计算机视觉、图像处理工作同学都在好奇 Taichi 是否可以加速 Python 中<b>图像处理</b>相关的计算，并与 OpenCV (<code>import cv2</code>) 协同工作、甚至在 GPU 上并行运行。本文就尝试针对这些问题进行初步探讨。我会带领大家揭秘女生爱用的<b>美颜滤镜</b>和男生爱玩的主机游戏《<b>对马岛之魂</b>》中的 HDR 效果的原理，讲解它们背后使用的几个从简单到困难逐渐递进的图像处理算法，包括高斯滤波器、双边滤波器、双边网格 (Bilateral Grid) 等，并和大家一起手把手从零开始写代码体验效果。相信读完这篇教程，不论读者是否从事图像处理方面，都可以有所收获。欢迎大家按需食用、批评斧正！</p><h2><b>前言</b></h2><p data-pid="wmDPQGXI">Python 是当前图像处理领域的主打语言之一。在计算机视觉（特别是深度学习图片预处理、模型训练）等复杂度较高，技术迭代速度快的领域，用 Python 快速开发出算法原型、验证效果是许多研发人员的首选方案。著名图像处理库 OpenCV 就提供了完整的 Python 封装，用户可以书写 Python 调用底层的 C++ 实现来获得不错的性能。</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-d52546e28070bf065898548f5bc57d94_b.jpg" data-caption="" data-size="normal" data-rawwidth="500" data-rawheight="649" class="origin_image zh-lightbox-thumb" width="500" data-original="https://pic1.zhimg.com/v2-d52546e28070bf065898548f5bc57d94_r.jpg"/></figure><p data-pid="6tRYxfQF">理想很丰满，现实很骨感。在实际的研发任务中，仅仅使用 OpenCV 的 Python 接口往往是不够的：当某些处理算法 OpenCV 没有提供，需要用户亲自实现时，Python 的性能就比较尴尬了。图像通常是以 NumPy 数组的形式存储在内存中的，当需要逐个遍历像素处理时，Python 的 for 循环效率很低。在需要实时处理的场景（比如摄像头传回的画面）或者数据量较大的时候，Python 的解释器开销会是个很大的性能瓶颈。</p><p data-pid="mtcT2rLZ">Taichi 在这一点上恰好可以帮到大家：</p><ol><li data-pid="OLcJ7vML">Taichi kernel 里的顶层 for 循环是自动并行的，用户无需分配和管理线程；</li><li data-pid="ZC5VAzfz">Taichi 的即时编译 (JIT) 机制可以把 Taichi 代码编译成高效的机器码，并通过指定后端跑在多核 CPU 或 GPU 等不同的后端上，用户无需担心编译和环境适配；</li><li data-pid="fe3-zEMM">Taichi 可以在 CPU、GPU 执行中无缝切换，对于计算量特别大的部分可以一键切换到 GPU 计算；</li><li data-pid="MT9moWQB">在同一份程序中用户可以在调用 OpenCV 和调用自己的 Taichi 实现中来回切换，所有工作都在同一份 Python 程序中完成。这和在 Python 外独立写一份 C++/CUDA 代码再用 ctypes/pybind11 等工具桥接比起来，使用和移植都方便很多。</li></ol><p data-pid="rTX5LYep">以上几点可以让用户在享受 Python 便利的同时，获得媲美 C++/CUDA 的运行效率。</p><p data-pid="KWgZ4Btq">本文接下来将通过三个篇章具体介绍如何使用 Taichi 加速 Python 图像处理：</p><ol><li data-pid="YkUqkNIH"><b>入门</b>篇：图像的转置与双线性插值；</li><li data-pid="ddkEdgJF"><b>进阶</b>篇：高斯滤波器与双边滤波器；</li><li data-pid="CppOItHX"><b>入魔</b>篇：双边网格与高动态范围色调映射 (Tone mapping)。</li></ol><p data-pid="nZ1YAFgt">在这些内容中大家可以看到这些图像处理算法是如何一步步被改进的，以及它们的一些有趣应用。</p><p data-pid="-C4-YK2J">在文末我们会讨论使用 Taichi 进行图像处理的注意事项，以及 Taichi 目前还存在哪些局限、不足，可以在未来改进。</p><p data-pid="cxavytMn">在开始正文之前，请大家确保自己的机器上已经安装了最新版本的 Taichi 和 opencv-python 这个库：</p><div class="highlight"><pre><code class="language-bash">pip3 install -U taichi opencv-python</code></pre></div><p data-pid="hddtjeIc">本文的所有代码都放在 GitHub 上：<a href="https://link.zhihu.com/?target=https%3A//github.com/taichi-dev/image-processing-with-taichi" class=" wrap external" target="_blank" rel="nofollow noreferrer">Image processing with Taichi</a>.</p><h2><b>入门：图像的转置与插值</b></h2><h3><b>图像的转置</b></h3><p data-pid="HdP4WIME">我们从一个最简单的例子开始，帮助大家了解使用 Taichi 进行处理图像的基本步骤：图像的转置。</p><p data-pid="QZnCckPX">图像的转置与矩阵的转置类似，就是把图像 <img src="https://www.zhihu.com/equation?tex=%28i%2C+j%29" alt="(i, j)" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=%28j%2C+i%29" alt="(j, i)" eeimg="1"/> 位置的像素交换位置 (transpose)：</p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-a2f1b5948f1e30c73f368154ec13596b_b.jpg" data-caption="" data-size="normal" data-rawwidth="1374" data-rawheight="502" class="origin_image zh-lightbox-thumb" width="1374" data-original="https://pic4.zhimg.com/v2-a2f1b5948f1e30c73f368154ec13596b_r.jpg"/></figure><p data-pid="i57c2tXt">我们首先导入所要使用的库，并调用 <code>ti.init()</code> 做一些初始化。这对每个 Taichi 程序来说都是必不可少的：</p><div class="highlight"><pre><code class="language-python3"><span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">taichi</span> <span class="k">as</span> <span class="nn">ti</span>

<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">()</span></code></pre></div><p data-pid="CoODR-x2">把小猫的图像读入内存：</p><div class="highlight"><pre><code class="language-python3"><span class="n">src</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s2">&#34;./images/cat.jpg&#34;</span><span class="p">)</span>
<span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">shape</span>
<span class="n">dst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

<span class="n">img2d</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">element_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Color image type</span></code></pre></div><p data-pid="lRHkxdtk">绝大多数 Python 图像处理库都假定图像具有 NumPy 的数组形式，OpenCV 也是如此。对灰度图像（单通道）对应的数组是二维的，形状是 (height, width)，彩色图像（多通道）对应的数组是三维的，形状是 (height, width, channels)。上面的代码中 OpenCV 读进来的图片 <code>src</code> 是一个三维 NumPy 数组，随后我们声明了一个数据类型与 <code>src</code> 相同，但长度和宽度与 <code>src</code> 交换的数组 <code>dst</code> 用于存放转置后的图片。</p><p data-pid="JMIDyttW">我们用下面这个函数 <code>transpose</code> 来处理图像的转置。从外表上看它和普通的 Python 函数没有什么两样，只不过开头加了一个装饰器 <code>ti.kernel</code>，所以是一个 Taichi kernel 函数：</p><div class="highlight"><pre><code class="language-python3"><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="n">src</span><span class="p">:</span> <span class="n">img2d</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="n">img2d</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">ndrange</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="n">dst</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span></code></pre></div><p data-pid="j-jf7pR8">这个 kernel 很短，不过有两点值得说道：</p><ol><li data-pid="RmSojfY2">在上面第二行代码中 <code>src</code>, <code>dst</code> 分别表示传入和输出的图像，它们都使用了 <code>img2d = ti.types.ndarray(element=1)</code> 作为类型标注。Taichi 允许你通过 <code>ti.types.ndarray()</code> 将一个 NumPy 数组作为参数传入 kernel，参数 <code>element_dim</code> 的具体含义读者可以暂时不用关心，只要知道它的目的是让我们可以同时操作像素的 RGB 三个分量。这种传参方式传递的是数组的<b>指针</b>，不会有额外的拷贝（注：如果在 GPU 上运行则会有 CPU/GPU 之间的自动数据转移），kernel 内部对数组的修改同样也会在外部生效。</li><li data-pid="wo6NeCHu"><code>for i, j in ti.ndrange(h, w):</code> 这句是一个顶层的 for 循环，它会自动并行遍历处理数组的所有元素。其中 <code>i</code> 遍历图像的所有行，<code>j</code> 遍历图像的所有列。</li></ol><p data-pid="qYe2kjCg">好了，我们只要调用这个 kernel 并将 <code>dst</code> 保存为图片：</p><div class="highlight"><pre><code class="language-python3"><span class="n">transpose</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
<span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="s2">&#34;cat_transpose.jpg&#34;</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span></code></pre></div><p data-pid="BaeYJCNc">就可以看到输出的转置图片。</p><p data-pid="jNbe04Tg">本例子的代码地址：<a href="https://link.zhihu.com/?target=https%3A//github.com/taichi-dev/image-processing-with-taichi/blob/main/image_transpose.py" class=" wrap external" target="_blank" rel="nofollow noreferrer">image_transpose.py</a>.</p><h3><b>双线性插值</b></h3><p data-pid="jtjY84eF">图像转置这个操作未免太过简单，我们再来看一个稍微复杂一点的例子：图像的<b>双线性插值</b>。</p><p data-pid="fzKqbGK_">双线性插值是图像<b>上采样</b> (upsampling) 中常用的手段。假设我们的小猫图片只有 96x64 像素，我们想把它放大 5 倍变成一张 480x320 的图像。直接粗暴地将每个像素变成一个 5x5 的 &#34;马赛克&#34; 可不是个好主意：</p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-513d3e269310d9cfc49c2c9ef685549f_b.png" data-caption="" data-size="normal" data-rawwidth="96" data-rawheight="64" class="content_image" width="96"/></figure><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-f093ea7ea09cfc9490d88cd97115f3e0_b.jpg" data-size="normal" data-rawwidth="480" data-rawheight="320" class="origin_image zh-lightbox-thumb" width="480" data-original="https://pic1.zhimg.com/v2-f093ea7ea09cfc9490d88cd97115f3e0_r.jpg"/><figcaption>将每个像素放大 5 倍的效果</figcaption></figure><p data-pid="HBIuHZHq">这是因为对放大后的图像中的某个像素 <img src="https://www.zhihu.com/equation?tex=%28i%2C+j%29" alt="(i, j)" eeimg="1"/>，它在原图像中对应的位置 <img src="https://www.zhihu.com/equation?tex=P%3D%28i%2F5%2C+j%2F5%29" alt="P=(i/5, j/5)" eeimg="1"/> 不见得正好落在原图像的某个像素上，直接取整或者四舍五入到最近的像素上，会导致图像看起来不太平滑。</p><p data-pid="pdH647nH">双线性插值则是考虑了 <img src="https://www.zhihu.com/equation?tex=P" alt="P" eeimg="1"/> 周围的四个像素，将它们的像素值加权平均作为 <img src="https://www.zhihu.com/equation?tex=P" alt="P" eeimg="1"/> 的像素值返回：（图片来自<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Bilinear_interpolation" class=" wrap external" target="_blank" rel="nofollow noreferrer">维基百科</a>）</p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-f4db1b1a7090efb60681abd5fe5a1775_b.jpg" data-caption="" data-size="normal" data-rawwidth="313" data-rawheight="438" class="content_image" width="313"/></figure><p data-pid="rQ1TmZtV">在上图中，<img src="https://www.zhihu.com/equation?tex=P%3D%28x%2Cy%29" alt="P=(x,y)" eeimg="1"/> 周围的四个像素</p><p data-pid="xIqGNafW"><img src="https://www.zhihu.com/equation?tex=Q_%7B11%7D%3D%28x_1%2Cy_1%29%2C%5C+Q_%7B12%7D%3D%28x_1%2Cy_2%29%2C%5C+Q_%7B21%7D%3D%28x_2%2Cy_1%29%2C%5C+Q_%7B22%7D%3D%28x_2%2Cy_2%29+%5C%5C" alt="Q_{11}=(x_1,y_1),\ Q_{12}=(x_1,y_2),\ Q_{21}=(x_2,y_1),\ Q_{22}=(x_2,y_2) \\" eeimg="1"/></p><p data-pid="om1VbZdl">构成一个单位正方形，四个小矩形的面积之和是 1，每个像素对应的权重系数是与它颜色相同的矩形的面积。比如当 <img src="https://www.zhihu.com/equation?tex=P" alt="P" eeimg="1"/> 越靠近左上角黄色的点 <img src="https://www.zhihu.com/equation?tex=Q_%7B12%7D" alt="Q_{12}" eeimg="1"/> 时，右下方黄色矩形的面积就会越大，从而 <img src="https://www.zhihu.com/equation?tex=Q_%7B12%7D" alt="Q_{12}" eeimg="1"/> 像素获得的权重也就越大。</p><p data-pid="zR33mgqg">这个计算可以用三个一维的线性插值来得到：首先分别对 <img src="https://www.zhihu.com/equation?tex=%28Q_%7B11%7D%2CQ_%7B21%7D%29" alt="(Q_{11},Q_{21})" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=%28Q_%7B12%7D%2CQ_%7B22%7D%29" alt="(Q_{12},Q_{22})" eeimg="1"/> 用权重 <img src="https://www.zhihu.com/equation?tex=x-x_1" alt="x-x_1" eeimg="1"/> 各作一次一维插值，然后把两个结果用权重 <img src="https://www.zhihu.com/equation?tex=y-y_1" alt="y-y_1" eeimg="1"/> 再作一次一维插值：</p><div class="highlight"><pre><code class="language-python3"><span class="kn">import</span> <span class="nn">taichi.math</span> <span class="k">as</span> <span class="nn">tm</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">bilinear_interp</span><span class="p">(</span><span class="n">src</span><span class="p">:</span> <span class="n">img2d</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="n">img2d</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">grouped</span><span class="p">(</span><span class="n">dst</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">I</span> <span class="o">/</span> <span class="n">scale</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># Bottom-left corner</span>
        <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">y1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Top-right corner</span>
        <span class="n">Q11</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">]</span>
        <span class="n">Q21</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">]</span>
        <span class="n">Q12</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y2</span><span class="p">]</span>
        <span class="n">Q22</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">]</span>
        <span class="n">R1</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">mix</span><span class="p">(</span><span class="n">Q11</span><span class="p">,</span> <span class="n">Q21</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span>
        <span class="n">R2</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">mix</span><span class="p">(</span><span class="n">Q12</span><span class="p">,</span> <span class="n">Q22</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span>
        <span class="n">dst</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">mix</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">y1</span><span class="p">),</span> <span class="n">ti</span><span class="o">.</span><span class="n">u8</span><span class="p">)</span> <span class="c1"># Round into uint8</span></code></pre></div><p data-pid="Elnz_x0_">在上面的代码中，我们用一个二维下标 <code>I</code> 遍历输出图像 <code>dst</code> 的所有像素，<code>I</code> 表示像素在 <code>dst</code> 中的行和列。<code>I/scale</code> 返回的是像素在原图 <code>src</code> 中的坐标 <img src="https://www.zhihu.com/equation?tex=%28x%2Cy%29" alt="(x,y)" eeimg="1"/>。<img src="https://www.zhihu.com/equation?tex=R_1" alt="R_1" eeimg="1"/> 是像素 <img src="https://www.zhihu.com/equation?tex=Q_%7B11%7D%3D%28x_1%2Cy_1%29%2CQ_%7B21%7D%3D%28x_2%2C+y_1%29" alt="Q_{11}=(x_1,y_1),Q_{21}=(x_2, y_1)" eeimg="1"/> 在 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"/> 方向上的插值，<img src="https://www.zhihu.com/equation?tex=R_2" alt="R_2" eeimg="1"/> 是像素 <img src="https://www.zhihu.com/equation?tex=Q_%7B12%7D%3D%28x_1%2Cy_2%29%2CQ_%7B22%7D%3D%28x_2%2C+y_2%29" alt="Q_{12}=(x_1,y_2),Q_{22}=(x_2, y_2)" eeimg="1"/> 在 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"/> 方向上的插值，<img src="https://www.zhihu.com/equation?tex=R_1%2CR_2" alt="R_1,R_2" eeimg="1"/> 在 <img src="https://www.zhihu.com/equation?tex=y" alt="y" eeimg="1"/> 方向上再插值一次就得到了最终的像素值。</p><p data-pid="_NpwuNXU">其中一维插值我们使用的是来自 <code>taichi.math</code> 模块的 <code>mix</code> 函数，定义如下：</p><div class="highlight"><pre><code class="language-python3"><span class="nd">@ti</span><span class="o">.</span><span class="n">func</span>
<span class="k">def</span> <span class="nf">mix</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span> <span class="c1"># also named &#34;lerp&#34; in other libraries</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">a</span></code></pre></div><p data-pid="fgXPE4tx">最终的结果如下所示：</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-f093ea7ea09cfc9490d88cd97115f3e0_b.jpg" data-size="normal" data-rawwidth="480" data-rawheight="320" class="origin_image zh-lightbox-thumb" width="480" data-original="https://pic1.zhimg.com/v2-f093ea7ea09cfc9490d88cd97115f3e0_r.jpg"/><figcaption>每个像素放大 5 倍的效果</figcaption></figure><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-4a9be8ae6d6fe3656541ab4cc993418e_b.jpg" data-size="normal" data-rawwidth="480" data-rawheight="320" class="origin_image zh-lightbox-thumb" width="480" data-original="https://pic3.zhimg.com/v2-4a9be8ae6d6fe3656541ab4cc993418e_r.jpg"/><figcaption>双线性插值的效果</figcaption></figure><p data-pid="jtnKqkZY">对比可见双线性插值给出的效果更为平滑。</p><p data-pid="UKzcIqDU">本例子的代码地址：<a href="https://link.zhihu.com/?target=https%3A//github.com/taichi-dev/image-processing-with-taichi/blob/main/image_bilinear_inpterpolation.py" class=" wrap external" target="_blank" rel="nofollow noreferrer">image_bilinear_inpterpolation.py</a>.</p><h2><b>进阶：高斯滤波器与双边滤波器</b></h2><h3><b>高斯滤波 (Gaussian filter)</b></h3><p data-pid="39tacyv-">高斯滤波是图像处理中常用的滤波算法之一，其作用是去除图像中的高频信息，使得图像变得模糊、平滑。高斯滤波是用一个矩阵与 2D 图像做卷积，这个矩阵叫做高斯核，它的元素来自二维高斯分布的采样。</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-7e28998cdd2f50ab758049701c48c370_b.jpg" data-size="normal" data-rawwidth="558" data-rawheight="478" class="origin_image zh-lightbox-thumb" width="558" data-original="https://pic1.zhimg.com/v2-7e28998cdd2f50ab758049701c48c370_r.jpg"/><figcaption>2D 高斯卷积核。图片来源：Durand and Dorsey, Fast Bilateral Filtering for the Display of High-Dynamic-Range Images, SIGGRAPH 2006</figcaption></figure><p data-pid="m_U4mM03">二维高斯分布的概率密度函数为</p><p data-pid="IwZ2g83J"><img src="https://www.zhihu.com/equation?tex=G%28x%2Cy%29+%3D+%5Cfrac%7B1%7D%7B2%5Cpi%5Csigma%5E2%7D%5Cmathrm%7Be%7D%5E%7B-%5Cfrac%7Bx%5E2%2By%5E2%7D%7B2%5Csigma%5E2%7D%7D.+%5C%5C" alt="G(x,y) = \frac{1}{2\pi\sigma^2}\mathrm{e}^{-\frac{x^2+y^2}{2\sigma^2}}. \\" eeimg="1"/></p><p data-pid="fiEFhCex">对一个 <img src="https://www.zhihu.com/equation?tex=%282k%2B1%29%5Ctimes+%282k%2B1%29" alt="(2k+1)\times (2k+1)" eeimg="1"/> 的高斯核 <img src="https://www.zhihu.com/equation?tex=K" alt="K" eeimg="1"/>，其元素来自 <img src="https://www.zhihu.com/equation?tex=G%28x%2Cy%29" alt="G(x,y)" eeimg="1"/> 在 <img src="https://www.zhihu.com/equation?tex=%5C%7B%28i%2Cj%29%5Cmid-k%5Cleq+i%2Cj%5Cleq+k%5C%7D" alt="\{(i,j)\mid-k\leq i,j\leq k\}" eeimg="1"/> 这些点的采样，比如  3x3 的高斯核是这样的：</p><p data-pid="UdZQpXVd"><img src="https://www.zhihu.com/equation?tex=K+%3D+%5Cbegin%7Bbmatrix%7DG%28-1%2C-1+%29%26G%280%2C+-1%29+%26+G%281%2C-1%29%5C%5C+G%28-1%2C0%29%26+G%280%2C0%29+%26+G%281%2C+0%29%5C%5C+G%28-1%2C+1%29%26+G%280%2C1%29+%26+G%281%2C+1%29%5Cend%7Bbmatrix%7D%E3%80%82%5C%5C" alt="K = \begin{bmatrix}G(-1,-1 )&amp;G(0, -1) &amp; G(1,-1)\\ G(-1,0)&amp; G(0,0) &amp; G(1, 0)\\ G(-1, 1)&amp; G(0,1) &amp; G(1, 1)\end{bmatrix}。\\" eeimg="1"/></p><p data-pid="lnrFoZir">由于 <img src="https://www.zhihu.com/equation?tex=G%28x%2Cy%29+%3D+%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5Cpi%5Csigma%5E2%7D%7D%5Cmathrm%7Be%7D%5E%7B-%5Cfrac%7Bx%5E2%7D%7B2%5Csigma%5E2%7D%7D+%5Ccdot+%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5Cpi%5Csigma%5E2%7D%7D%5Cmathrm%7Be%7D%5E%7B-%5Cfrac%7By%5E2%7D%7B2%5Csigma%5E2%7D%7D+%3D+G_1%28x%29G_1%28y%29+%5C%5C" alt="G(x,y) = \frac{1}{\sqrt{2\pi\sigma^2}}\mathrm{e}^{-\frac{x^2}{2\sigma^2}} \cdot \frac{1}{\sqrt{2\pi\sigma^2}}\mathrm{e}^{-\frac{y^2}{2\sigma^2}} = G_1(x)G_1(y) \\" eeimg="1"/> 是两个一维密度函数的乘积，所以高斯核是可分的，<img src="https://www.zhihu.com/equation?tex=K" alt="K" eeimg="1"/> 可以写成一维向量</p><p data-pid="Wf_q9Plk"><img src="https://www.zhihu.com/equation?tex=v%3D%28G_1%28-k%29%2CG_1%28-k%2B1%29%2C%5Cldots%2CG_1%28k%29%29%5ET+%5C%5C" alt="v=(G_1(-k),G_1(-k+1),\ldots,G_1(k))^T \\" eeimg="1"/></p><p data-pid="8W3668lb">与自身转置的乘积：<img src="https://www.zhihu.com/equation?tex=K%3Dv%5Ccdot+v%5ET" alt="K=v\cdot v^T" eeimg="1"/>。这种情形图像与 <img src="https://www.zhihu.com/equation?tex=K" alt="K" eeimg="1"/> 的二维卷积可以分解为两个一维卷积：先对图像的每一列用 <img src="https://www.zhihu.com/equation?tex=v" alt="v" eeimg="1"/> 做一次一维卷积，然后对结果的每一行用 <img src="https://www.zhihu.com/equation?tex=v%5ET" alt="v^T" eeimg="1"/> 再做一次一维卷积（证明见<a href="https://link.zhihu.com/?target=http%3A//www.songho.ca/dsp/convolution/convolution.html%23convolution_2d" class=" wrap external" target="_blank" rel="nofollow noreferrer">这个网页</a>）。这样就把二维卷积的复杂度从 <img src="https://www.zhihu.com/equation?tex=O%28m%2An%2Ak%5E2%29" alt="O(m*n*k^2)" eeimg="1"/> 减少到了 <img src="https://www.zhihu.com/equation?tex=O%28m%2An%2Ak%29" alt="O(m*n*k)" eeimg="1"/>。</p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-b5b08766ef7078ef2e2f9204431691b9_b.jpg" data-size="normal" data-rawwidth="858" data-rawheight="380" class="origin_image zh-lightbox-thumb" width="858" data-original="https://pic2.zhimg.com/v2-b5b08766ef7078ef2e2f9204431691b9_r.jpg"/><figcaption>从左到右：原图、只对列滤波的中间结果、完整高斯滤波的结果，\sigma=5.0</figcaption></figure><p data-pid="WlBC6a4w">我们首先开辟一个 1D field （即一维数组）用于存放 1 维的高斯核：</p><div class="highlight"><pre><code class="language-python3"><span class="n">weights</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">offset</span><span class="o">=-</span><span class="mi">512</span><span class="p">)</span></code></pre></div><p data-pid="U4oM6OCW">这个 field 的长度是 1024，在绝大多数场景下肯定够用了。注意到选项 <code>offset=-512</code> 表示这个 field 的下标是从 -512 开始的，到 511 为止。这是 Taichi 提供的 field 的 offset 功能，好处是下标范围关于原点是对称的，这样可以简化代码。我们用一个 <code>@ti.func</code> 来初始化这个 field:</p><div class="highlight"><pre><code class="language-python3"><span class="nd">@ti</span><span class="o">.</span><span class="n">func</span>
<span class="k">def</span> <span class="nf">compute_weights</span><span class="p">(</span><span class="n">radius</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">ti</span><span class="o">.</span><span class="n">loop_config</span><span class="p">(</span><span class="n">serialize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">radius</span><span class="p">,</span> <span class="n">radius</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">val</span>

    <span class="n">ti</span><span class="o">.</span><span class="n">loop_config</span><span class="p">(</span><span class="n">serialize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">radius</span><span class="p">,</span> <span class="n">radius</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">total</span></code></pre></div><p data-pid="OFifQ_iw">其中参数 <code>radius</code> 控制高斯核的大小：高斯核中实际使用的元素下标范围为 <code>[-radius, radius]</code>，<code>sigma</code> 是 Gauss 密度函数的方差。</p><p data-pid="i426wUwe">这里值得注意的是我们使用了 <code>ti.loop_config(serialize=True)</code> 关闭了紧随其后的 for 循环的并行。这是因为在计算量比较小的情形，在 CPU/GPU 上生成大量线程的开销可能反而占了大头，所以我们让 for 语句串行执行即可。计算高斯核每个元素时，可以不用关心系数 <img src="https://www.zhihu.com/equation?tex=1%2F%7B2%5Cpi%5Csigma%5E2%7D" alt="1/{2\pi\sigma^2}" eeimg="1"/>，最后用 <code>total</code> 变量统一做归一化。</p><p data-pid="ZU4plt_r">接下来我们来计算两次实际的一维卷积。我们开辟一个尺寸为 1024x1024 的 Vector Field (其实就是元素是 RGB 的二维数组) 用于存储第一次滤波后的中间图像：</p><div class="highlight"><pre><code class="language-python3"><span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s1">&#39;./images/mountain.jpg&#39;</span><span class="p">)</span>
<span class="n">img_blurred</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">u8</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">1024</span><span class="p">))</span></code></pre></div><p data-pid="64uCkEGA">然后先对列、再对行分别做一维滤波：</p><div class="highlight"><pre><code class="language-python3"><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">gaussian_blur</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">img2d</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="n">img_blurred</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">blur_radius</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">sigma</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> 
    <span class="n">compute_weights</span><span class="p">(</span><span class="n">blur_radius</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
    
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">ndrange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">l_begin</span><span class="p">,</span> <span class="n">l_end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">blur_radius</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">blur_radius</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">total_rgb</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l_begin</span><span class="p">,</span> <span class="n">l_end</span><span class="p">):</span>
            <span class="n">total_rgb</span> <span class="o">+=</span> <span class="n">img</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">l</span><span class="p">]</span>

        <span class="n">img_blurred</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_rgb</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">u8</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">ndrange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">l_begin</span><span class="p">,</span> <span class="n">l_end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">blur_radius</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">blur_radius</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">total_rgb</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l_begin</span><span class="p">,</span> <span class="n">l_end</span><span class="p">):</span>
            <span class="n">total_rgb</span> <span class="o">+=</span> <span class="n">img_blurred</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">l</span><span class="p">]</span>

        <span class="n">img</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_rgb</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">u8</span><span class="p">)</span></code></pre></div><p data-pid="D6P8XvbS">在代码 3-5 行处，我们先将滤波后的图像置为 0，并初始化了高斯滤波器。接下来 7-14 行和 16-22 行的两个 for 循环分别是对列、行的一维滤波，它们本质上是一样的，只不过第一个循环会将列滤波的结果存在 <code>img_blurred</code> 中，第二个循环将结果写回原图像 <code>img</code>。第一个 for 循环中 <code>img_blurred[i, j]</code> 的值就是将滤波器竖起来覆盖在 <code>img</code> 上，使得其中心位置与 <code>img[i, j]</code> 重叠，然后计算滤波器的所有元素与其下方 <code>img</code> 元素乘积之和。就是这么简单！</p><p data-pid="I9ZSwUfm">本例子的代码地址：<a href="https://link.zhihu.com/?target=https%3A//github.com/taichi-dev/image-processing-with-taichi/blob/main/gaussian_filter_separate.py" class=" wrap external" target="_blank" rel="nofollow noreferrer">gaussian_filter_separate.py</a>.</p><h3><b>双边滤波器 (Bilateral Filter)</b></h3><p data-pid="urtpmHZ-">高斯滤波器总是用固定的权重计算，所以虽然它会让图像变得平滑，但同样也会丢失图像的一部分细节。比如某些边缘的部分会模糊掉。</p><p data-pid="mJN7UbZU">那有没有什么办法，可以在<b>保持图像边缘细节</b>的同时实现平滑呢？既然高斯滤波器的权重只与像素之间的距离有关，何不再加入一个依赖于像素值差的权重因子呢？这就是双边滤波的思路：</p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-899daeaaa8c94b9cb07a82c28233c583_b.jpg" data-size="normal" data-rawwidth="1280" data-rawheight="323" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic4.zhimg.com/v2-899daeaaa8c94b9cb07a82c28233c583_r.jpg"/><figcaption>图片来源：Durand and Dorsey, Fast Bilateral Filtering for the Display of High-Dynamic-Range Images, SIGGRAPH 2006</figcaption></figure><p data-pid="luj2_8jA">上图中，我们将一个 2D 灰度（单 channel）图像 plot 到 3D 空间，其中高度就是像素的值。可以看到，双边滤波器可以在保持“悬崖”（即图像中的边缘）的同时，光滑两边的“山坡”。</p><p data-pid="Uc0wwdt1"><img src="https://www.zhihu.com/equation?tex=I%5E%7B%5Ctext%7Bfiltered%7D%7D%28x%29+%3D+%5Cfrac%7B1%7D%7BW_p%7D%5Csum_%7Bx_i%5Cin%5COmega%7DI%28x_i%29G_%7B%5Csigma_r%7D%28%5C%7CI%28x_i%29-I%28x%29%5C%7C%29G_%7B%5Csigma_s%7D%28%5C%7Cx_i-x%5C%7C%29.+%5C%5C" alt="I^{\text{filtered}}(x) = \frac{1}{W_p}\sum_{x_i\in\Omega}I(x_i)G_{\sigma_r}(\|I(x_i)-I(x)\|)G_{\sigma_s}(\|x_i-x\|). \\" eeimg="1"/></p><p data-pid="gV91XSqp">其中 <img src="https://www.zhihu.com/equation?tex=G_%7B%5Csigma_s%7D" alt="G_{\sigma_s}" eeimg="1"/> 是上一小节中基于像素距离的高斯核，<img src="https://www.zhihu.com/equation?tex=G_%7B%5Csigma_r%7D" alt="G_{\sigma_r}" eeimg="1"/> 是新引入的基于<b>像素差距</b>的高斯核：</p><p data-pid="GAM9YD9-"><img src="https://www.zhihu.com/equation?tex=G_%7B%5Csigma_r%7D%28%5C%7CI%28x_i%29-I%28x%29%5C%7C%29%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5Cpi%5Csigma_r%5E2%7D%7D%5Cmathrm%7Be%7D%5E%7B-%5Cfrac%7B%5C%7CI%28x_i%29-I%28x%29%5C%7C%5E2%7D%7B2%5Csigma_r%5E2%7D%7D.+%5C%5C" alt="G_{\sigma_r}(\|I(x_i)-I(x)\|)=\frac{1}{\sqrt{2\pi\sigma_r^2}}\mathrm{e}^{-\frac{\|I(x_i)-I(x)\|^2}{2\sigma_r^2}}. \\" eeimg="1"/></p><p data-pid="TfgQMOiW"><img src="https://www.zhihu.com/equation?tex=W_P" alt="W_P" eeimg="1"/> 是归一化系数。所以在计算 <img src="https://www.zhihu.com/equation?tex=%28i%2Cj%29" alt="(i,j)" eeimg="1"/> 位置像素的滤波时，来自像素 <img src="https://www.zhihu.com/equation?tex=%28k%2Cl%29" alt="(k,l)" eeimg="1"/> 的权重贡献为</p><p data-pid="GkDfEdp-"><img src="https://www.zhihu.com/equation?tex=w%28i%2C+j%2C+k%2C+l%29+%3D+%5Cmathrm%7Bexp%7D%5Cleft%28%7B-%5Cfrac%7B%28i-k%29%5E2%2B%28j-l%29%5E2%7D%7B2%5Csigma_s%5E2%7D+-%5Cfrac%7B%5C%7CI%28i%2C+j%29-I%28k%2C+l%29%5C%7C%5E2%7D%7B2%5Csigma_r%5E2%7D%7D%5Cright%29.+%5C%5C" alt="w(i, j, k, l) = \mathrm{exp}\left({-\frac{(i-k)^2+(j-l)^2}{2\sigma_s^2} -\frac{\|I(i, j)-I(k, l)\|^2}{2\sigma_r^2}}\right). \\" eeimg="1"/></p><p data-pid="54yWfPjw">从而两个像素的差 <img src="https://www.zhihu.com/equation?tex=%5C%7CI%28i%2Cj%29-I%28k%2Cl%29%5C%7C" alt="\|I(i,j)-I(k,l)\|" eeimg="1"/>越大，在计算滤波时 <img src="https://www.zhihu.com/equation?tex=I%28k%2Cl%29" alt="I(k,l)" eeimg="1"/> 贡献的值就越小，从而起到了保持边缘的效果：</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-e06ec4cffd708eb35623c021076401f8_b.jpg" data-size="normal" data-rawwidth="540" data-rawheight="359" class="origin_image zh-lightbox-thumb" width="540" data-original="https://pic1.zhimg.com/v2-e06ec4cffd708eb35623c021076401f8_r.jpg"/><figcaption>左图：原始图像。右图：双边滤波后的图像</figcaption></figure><p data-pid="PVsA_j-m">双边滤波器不是可分的，它不能分解成两个一维卷积，所以我们只能老老实实写二维卷积了：</p><div class="highlight"><pre><code class="language-python3"><span class="n">img_filtered</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">u8</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">1024</span><span class="p">))</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">bilateral_filter</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">img2d</span><span class="p">,</span> <span class="n">sigma_s</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">sigma_r</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">):</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">blur_radius_s</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">sigma_s</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">ndrange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">k_begin</span><span class="p">,</span> <span class="n">k_end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">blur_radius_s</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">blur_radius_s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">l_begin</span><span class="p">,</span> <span class="n">l_end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">blur_radius_s</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">blur_radius_s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">total_rgb</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">total_weight</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">ndrange</span><span class="p">((</span><span class="n">k_begin</span><span class="p">,</span> <span class="n">k_end</span><span class="p">),</span> <span class="p">(</span><span class="n">l_begin</span><span class="p">,</span> <span class="n">l_end</span><span class="p">)):</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="p">((</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">sigma_s</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span>
                <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span> <span class="o">-</span> <span class="n">img</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">))</span><span class="o">.</span><span class="n">norm_sqr</span><span class="p">()</span> <span class="o">/</span> <span class="n">sigma_r</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">dist</span><span class="p">)</span>
            <span class="n">total_rgb</span> <span class="o">+=</span> <span class="n">img</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span>
            <span class="n">total_weight</span> <span class="o">+=</span> <span class="n">w</span>

        <span class="n">img_filtered</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">total_rgb</span> <span class="o">/</span> <span class="n">total_weight</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">u8</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">ndrange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">img</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">img_filtered</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span></code></pre></div><p data-pid="wWwDRL00">这个过程和高斯滤波是一样的，区别在于我们只需要用一个 for 循环并行处理所有像素，用 <code>total_weights</code> 统计所有来自高斯核覆盖的像素权重，用 <code>total_rgb</code> 统计这些像素值的加权和，最后做归一化处理。</p><h3><b>应用：用双边滤波器进行磨皮美颜</b></h3><p data-pid="3Jh9qnmd">双边滤波器有着广泛的应用，最典型的就是图像降噪 (denoising)、图像平滑 (image smoothing) 等，而后者是一种经典的<b>磨皮美颜</b>算法：</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-a4a194b9937c0d63a2829d74fcf8cd90_b.jpg" data-caption="" data-size="normal" data-rawwidth="1992" data-rawheight="1022" class="origin_image zh-lightbox-thumb" width="1992" data-original="https://pic1.zhimg.com/v2-a4a194b9937c0d63a2829d74fcf8cd90_r.jpg"/></figure><p data-pid="Gq4S8y0j">可以看到，双边滤波器可以在保持图片中锐利边缘的同时，抹去局部细节，起到磨皮效果。我还放了一张相同半径的高斯滤波器对比，可以看到高斯模糊会模糊边缘，效果是无法接受的。（输入图片来源：Pixarbay）</p><p data-pid="xpSQpEsg">本例子的代码地址：<a href="https://link.zhihu.com/?target=https%3A//github.com/taichi-dev/image-processing-with-taichi/blob/main/bilateral_filter.py" class=" wrap external" target="_blank" rel="nofollow noreferrer">bilateral_filter.py</a>.</p><h2><b>入魔：双边网格（Bilateral Grid）</b></h2><h3><b>双边滤波器的性能问题</b></h3><p data-pid="0gerx9kq">双边滤波虽然能够在保持边缘的同时实现平滑，但它的性能是个很大的问题。前面提到 2D 的高斯滤波器可以通过分解为两个 1D 的高斯滤波解决，甚至对于较大的卷积核更有快速傅里叶变换 (FFT) 进一步提升性能，但双边滤波器就没有这种福分了：它不是可分的，无法表示成两个独立的 1D 卷积；由于依赖图像内容，所以也不能使用 FFT。</p><p data-pid="mTYvCzDT">那么有没有什么办法可以改造双边滤波器，使得它是可分的呢？答案是有的，这就是下面要介绍的<b>双边网格</b> (Bilateral Grid) 滤波。</p><p data-pid="b2NLuBbu">双边网格 (Bilateral Grid) 出自论文 <a href="https://link.zhihu.com/?target=https%3A//people.csail.mit.edu/sparis/publi/2007/siggraph/Chen_07_Bilateral_Grid.pdf" class=" wrap external" target="_blank" rel="nofollow noreferrer">Chen et al., SIGGRAPH 2007</a>，是双边滤波器的加速版本。这个方法非常精彩，是一个通过提升维度来简化问题的范例。它包含一系列操作步骤，所以乍看起来会有点复杂，但我向你保证它背后的想法是很简单的。</p><blockquote data-pid="2IEyLYO7"> 八卦一下：这篇文章的 last author 是我的 Ph.D. 导师 Fredo Durand，第一作者 Jiawen Chen 在是大我十几届，没有照过面的 MIT 师兄，第二作者 Sylvain Paris 是 Adobe 著名研究员，当年是 Fredo 的 post-doc。Fredo 真是从真实感渲染、计算摄影到编译器啥都能搞，太能打了...<br/> </blockquote><p data-pid="H2nsp3hY">双边网格的核心想法是通过维度提升使得双边滤波可分。双边滤波不可分的原因是卷积核里面带有图像的像素值，如果把这个像素值的部分作为第三个维度上的独立卷积，不就可以实现可分了吗？</p><p data-pid="Oih2ZzfS">比如以灰度图像为例，图像是一个二维网格 <img src="https://www.zhihu.com/equation?tex=I" alt="I" eeimg="1"/>，每个元素存储的是像素的灰度值。我们把这个<b>二维网格提升为一个三维网格</b> <img src="https://www.zhihu.com/equation?tex=%5Cwidetilde%7BI%7D" alt="\widetilde{I}" eeimg="1"/>，第三个维度的长度是灰度的范围 [0, 255]，从而整个网格大小为 <img src="https://www.zhihu.com/equation?tex=w%5Ctimes+h%5Ctimes+255" alt="w\times h\times 255" eeimg="1"/>。网格的 <img src="https://www.zhihu.com/equation?tex=%28i%2C+j%2C+k%29" alt="(i, j, k)" eeimg="1"/> 位置的元素存储的值如下：</p><p data-pid="AcWik2Lz"><img src="https://www.zhihu.com/equation?tex=%5Cwidetilde%7BI%7D%28i%2C+j%2C+k%29+%3D+%5Cbegin%7Bcases%7D%28I%28i%2Cj%29%2C1%29%2C+%26+%5Ctext%7Bif+%7D+k%3DI%28i%2Cj%29%5C%5C+%280%2C+0%29.+%26+%5Ctext%7Botherwise%7D%5Cend%7Bcases%7D+%5C%5C" alt="\widetilde{I}(i, j, k) = \begin{cases}(I(i,j),1), &amp; \text{if } k=I(i,j)\\ (0, 0). &amp; \text{otherwise}\end{cases} \\" eeimg="1"/></p><p data-pid="JuagTABi">对这个三维网格做三维的高斯滤波，假设得到的结果是三维网格 <img src="https://www.zhihu.com/equation?tex=%5Cwidetilde%7B%5CGamma%7D%3A%5Cwidetilde%7B%5CGamma%7D%28i%2Cj%2Ck%29+%3D+%28z%2C+w%29" alt="\widetilde{\Gamma}:\widetilde{\Gamma}(i,j,k) = (z, w)" eeimg="1"/>，则 <img src="https://www.zhihu.com/equation?tex=%5CGamma%28i%2Cj%29%3Dz%2Fw" alt="\Gamma(i,j)=z/w" eeimg="1"/> 就是所求的对 <img src="https://www.zhihu.com/equation?tex=I" alt="I" eeimg="1"/> 双边滤波后的结果。</p><p data-pid="_gCmNUT3">这里有个技巧值得注意：网格存储 <img src="https://www.zhihu.com/equation?tex=%28I%28i%2Cj%29%2C1%29" alt="(I(i,j),1)" eeimg="1"/> 这个二元组是为了在卷积时用第一个位置记录像素值的加权和 <img src="https://www.zhihu.com/equation?tex=%5Csum+w_iI%28x_i%29" alt="\sum w_iI(x_i)" eeimg="1"/>，用第二个位置记录权重的和 <img src="https://www.zhihu.com/equation?tex=%5Csum+w_i" alt="\sum w_i" eeimg="1"/>，最后相除就得到了归一化的结果。</p><p data-pid="XvRem4g0">下图是原论文中给出的一维提升到二维的例子，包含三个步骤：网格创建 (<b>create</b>)，网格处理（<b>process</b>）、网格切片（<b>slice</b>）。</p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-b2dc8112592c86c2acadf7dde4416ea5_b.jpg" data-size="normal" data-rawwidth="1280" data-rawheight="261" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic2.zhimg.com/v2-b2dc8112592c86c2acadf7dde4416ea5_r.jpg"/><figcaption>Bilateral Grid 三部曲 (Create, process &amp; slice)。图片来自 SIGGRAPH 2007 的 Bilateral Grid paper</figcaption></figure><p data-pid="xdc1tMnR">上图中最左边输入的是一维的信号，它的两段之间有一个明显的间断（即边缘）。提升为二维网格（左边第二张图）后，它们变成图像中两个不连通的区域。如果对这个图像作二维的高斯滤波的话，由于两个区域间断处的像素距离比较远，所以它们在滤波时给对方贡献的权重很小，甚至没有，所以双边网格是可以保持边缘信息的。当然，上面这张图是为了画图简便，采用了一维信号作为输入，所以 Grid 是二维的；在我们的情况中，输入是二维的，Grid 就是三维的。</p><p data-pid="SnLTyCwJ">在具体实现中，由于对一张 1024x1024=1MB 的灰度图，升维后网格的大小是 1024x1024x256=256MB，占据的空间实在是有点大，而且我们要的本来就是滤波后的结果，维护一个精确的大网格没有必要，所以我们会按比例缩小创建的网格（降采样），然后在滤波后再超采样回去。</p><p data-pid="TbV-V2N-">具体步骤和代码介绍如下，我们采用<b>灰度</b>图像作为输入。</p><h3><b>第一步：Create, 创建网格（降采样与升维）</b></h3><p data-pid="dCJE1mSQ">我们首先声明两个 VectorField 用于存储三维网格及其滤波的中间结果，大小固定为 512x512x128 (32MB)。再声明一个形状是 2x512 的 field 用于存储滤波器的系数，2 表示有两个滤波器，一个给图像的空域 (spatial space)，一个给像素的值域 (range space)。</p><div class="highlight"><pre><code class="language-python3"><span class="n">grid</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>
<span class="n">grid_blurred</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>
<span class="n">weights</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">512</span><span class="p">),</span> <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">256</span><span class="p">))</span></code></pre></div><p data-pid="KOExyw0J">我们省略初始化 <code>weights</code> 的代码部分，这个和之前高斯滤波器中的步骤是完全类似的。初始化 <code>grid</code> 的代码如下：（以下代码在 kernel 内执行）</p><div class="highlight"><pre><code class="language-python3"><span class="n">grid</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">ndrange</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
    <span class="n">lum</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
    <span class="n">grid</span><span class="p">[</span><span class="n">ti</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">s_s</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">),</span>
         <span class="n">ti</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">j</span> <span class="o">/</span> <span class="n">s_s</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">),</span>
         <span class="n">ti</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">lum</span> <span class="o">/</span> <span class="n">s_r</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">tm</span><span class="o">.</span><span class="n">vec2</span><span class="p">(</span><span class="n">lum</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">grid_blurred</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">grid_n</span> <span class="o">=</span> <span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">s_s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">s_s</span>
<span class="n">grid_m</span> <span class="o">=</span> <span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s_s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">s_s</span>
<span class="n">grid_l</span> <span class="o">=</span> <span class="p">(</span><span class="mi">256</span> <span class="o">+</span> <span class="n">s_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">s_r</span></code></pre></div><p data-pid="lCXpHq93">其中 <code>s_s</code> 是图像大小的缩放因子，<code>s_r</code> 是值域 [0, 255] 的缩放因子。<code>grid_blurred</code> 初始化为 0。</p><p data-pid="ySAMD0-B">顺便我们计算了缩放后的三维网格的实际大小 <code>grid_n</code>, <code>grid_m</code>, <code>grid_l</code>。</p><h3><b>第二步：Process, 网格操作（高斯模糊等）</b></h3><p data-pid="CIFtoD7_">现在我们可以对三维网格 <code>grid</code> 做三维高斯滤波了。这一步代码看似很长，其实反而是最简单的部分，因为它不过是我们前面介绍过的高斯滤波部分的重复，只是多了一次滤波。</p><p data-pid="o_-KsvtI">注意经典的 Bilateral filter 算子在这一步变成了三个可分 filter：（以下代码均在 kernel 内执行）</p><div class="highlight"><pre><code class="language-python3"><span class="n">blur_radius</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">sigma_s</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">ndrange</span><span class="p">(</span><span class="n">grid_n</span><span class="p">,</span> <span class="n">grid_m</span><span class="p">,</span> <span class="n">grid_l</span><span class="p">):</span>
    <span class="n">l_begin</span><span class="p">,</span> <span class="n">l_end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">blur_radius</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">grid_n</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">blur_radius</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l_begin</span><span class="p">,</span> <span class="n">l_end</span><span class="p">):</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">l</span><span class="p">]</span>

    <span class="n">grid_blurred</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">total</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">ndrange</span><span class="p">(</span><span class="n">grid_n</span><span class="p">,</span> <span class="n">grid_m</span><span class="p">,</span> <span class="n">grid_l</span><span class="p">):</span>
    <span class="n">l_begin</span><span class="p">,</span> <span class="n">l_end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">blur_radius</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">grid_m</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">blur_radius</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l_begin</span><span class="p">,</span> <span class="n">l_end</span><span class="p">):</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">grid_blurred</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">l</span><span class="p">]</span>
    <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">total</span>

<span class="n">blur_radius</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">sigma_r</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">ndrange</span><span class="p">(</span><span class="n">grid_n</span><span class="p">,</span> <span class="n">grid_m</span><span class="p">,</span> <span class="n">grid_l</span><span class="p">):</span>
    <span class="n">l_begin</span><span class="p">,</span> <span class="n">l_end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">blur_radius</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">grid_l</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="n">blur_radius</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l_begin</span><span class="p">,</span> <span class="n">l_end</span><span class="p">):</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">l</span><span class="p">]</span>

    <span class="n">grid_blurred</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">total</span></code></pre></div><p data-pid="mHn7dExC">这一段包含三个顶层的 for 循环，前两个是对空间滤波，使用的权重来自 <code>weights[0]</code>；第三个是对值域滤波，使用的权重来自 <code>weights[1]</code>。</p><p data-pid="cgf8gRi7">我们把每次滤波的结果轮流写入 <code>grid_blurred</code> 和 <code>grid</code>。三轮滤波后最终的结果存储在 <code>grid_blurred</code> 中。</p><h3><b>第三步：Slice, 网格切片（三线性插值）</b></h3><p data-pid="VLHdiTs1">最后我们来从“缩水”的网格 <code>grid_blurred</code> 中超采样获得滤波后的图像。这一步同样非常简单：（以下代码同样需要在 kernel 内执行）</p><div class="highlight"><pre><code class="language-python3"><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">ndrange</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
    <span class="n">lum</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
    <span class="n">sample</span> <span class="o">=</span> <span class="n">sample_grid</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">s_s</span><span class="p">,</span> <span class="n">j</span> <span class="o">/</span> <span class="n">s_s</span><span class="p">,</span> <span class="n">lum</span> <span class="o">/</span> <span class="n">s_r</span><span class="p">)</span>
    <span class="n">img</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">u8</span><span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">sample</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></code></pre></div><p data-pid="hPTXvcdL">首先我们定位到未缩水的完整三维网格的 <code>[i, j, img[i,j]]</code> 处，这里的网格值可以根据缩水后的网格在 <code>[i / s_s, j / s_s, lum / s_r]</code> 处的值用一个插值函数 <code>sample_grid</code> 得出来，得到的结果是一个二元组 <img src="https://www.zhihu.com/equation?tex=%28z%2Cw%29" alt="(z,w)" eeimg="1"/> ，<img src="https://www.zhihu.com/equation?tex=z" alt="z" eeimg="1"/> 是像素的加权和，<img src="https://www.zhihu.com/equation?tex=w" alt="w" eeimg="1"/> 是权重的和，二者相除即为滤波后的值。</p><p data-pid="dW5fxs55">插值函数 <code>sample_grid</code> 是个啥？读者不难想到，它正是我们之前介绍的双线性插值的升维版本：三线性插值。和双线性插值类似，三线性插值对应的是单位正方体八个顶点的加权和。它可以通过先在正方体上下两个表面分别做一次双线性插值，然后将两个结果再做一次线性插值得到。</p><p data-pid="55hTRn5x">本例子的代码地址：<a href="https://link.zhihu.com/?target=https%3A//github.com/taichi-dev/image-processing-with-taichi/blob/main/bilateral_grid.py" class=" wrap external" target="_blank" rel="nofollow noreferrer">bilateral_grid.py</a>.</p><p data-pid="BJJIoo-T"><b>总结一下:</b> 通过把 2D 图像升级到 3D，我们用一个 3D 可分卷积代替了一个 2D 的不可分 “卷积”。这样做会有性能优势吗？我们来分析一下：</p><ul><li data-pid="FDITSyRx">3D 网格的 x, y 分辨率其实比原图低很多，所以整个 3D 网格的 “体素” 数目其实不见得就比 2D 图像的像素多。</li><li data-pid="fdfRMsaK">另一方面，本来非常昂贵的不可分 2D 卷积被拆分成了可分的三次卷积，计算量大幅下降。</li><li data-pid="7cM0SZ6o">当然，整个系统的另一大亮点是非常 GPU 友好，特别是使用 Taichi 实现的时候 :-)</li></ul><h3><b>应用：实时 Local Tone Mapping（“HDR” 效果）</b></h3><p data-pid="3foAHxU1">人眼能够感知到的<b>动态范围</b>，即最亮和最暗光强的比值，能够达到 <img src="https://www.zhihu.com/equation?tex=1%3A10%5E9" alt="1:10^9" eeimg="1"/> ，但是普通显示设备上只能做到 <img src="https://www.zhihu.com/equation?tex=1%3A100+%5Csim+1%3A1000" alt="1:100 \sim 1:1000" eeimg="1"/>，而比较好的摄影器材的动态范围则在显示器和人眼之间。不经处理地将高动态范围（High dynamic range, HDR）的图片在低动态范围 (Low Dynamic Range, LDR) 的设备上显示就会造成很多尴尬，难以同时展示图片亮部和暗部的细节：</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-f0ac03a649af6067315594c7fc41c598_b.jpg" data-size="normal" data-rawwidth="1269" data-rawheight="993" class="origin_image zh-lightbox-thumb" width="1269" data-original="https://pic1.zhimg.com/v2-f0ac03a649af6067315594c7fc41c598_r.jpg"/><figcaption>大光比照片的尴尬：不增加亮度吧，暗的地方（比如树枝）一片死黑；增加亮度吧，树枝能看见了，天空又完全过曝了。</figcaption></figure><p data-pid="5hsvP_S4">色调映射（Tone mapping）是解决这个问题的良药。Tone mapping 有两种，一种是对屏幕上所有的像素用同一个函数调整亮度，即 Global tone mapping；另一种则会根据每个像素周围的像素智能地根据上下文 (context) 进行调整亮度，即 Local tone mapping，往往更为有效。</p><p data-pid="Q5WzRe6B">而 Local tone mapping 和 Bilateral filter 有什么联系呢？不难想到 Bilateral filter 最大的优势就在于 “<b>保留边缘，抹去局部细节</b>”，而 Local tone mapping 的需求恰恰是 “<b>去掉边缘，保留局部细节</b>”。由于人眼对于局部细节更为敏感，<b>反向</b>的 Bilateral filter，如果用在图片的亮度上，就可以有效压缩 HDR 图片的动态范围，便于在 LDR 设备上显示。Bilateral filter 用于局部色调映射的具体步骤如下：</p><ol><li data-pid="u9dwP0bc">对 RGB 的图片计算 log luminance（R、G、B 的加权求和后，取对数），称此图为 <img src="https://www.zhihu.com/equation?tex=L" alt="L" eeimg="1"/>；</li><li data-pid="2co_inWy">对 log luminance 图片 <img src="https://www.zhihu.com/equation?tex=L" alt="L" eeimg="1"/> 进行 bilateral filtering，得到光滑后的 log luminance base 图片，即 <img src="https://www.zhihu.com/equation?tex=B+%3D" alt="B =" eeimg="1"/> bilateral_filter<img src="https://www.zhihu.com/equation?tex=%28L%29" alt="(L)" eeimg="1"/>；</li><li data-pid="m5XlBeFP">计算亮度细节 (detail) 图层 <img src="https://www.zhihu.com/equation?tex=D+%3D+L+-+B" alt="D = L - B" eeimg="1"/>，这一部分是我们希望保留的亮度细节；</li><li data-pid="EB5mWfPy">将 B 进行压缩，<img src="https://www.zhihu.com/equation?tex=B%27+%3D+%5Calpha+B" alt="B&#39; = \alpha B" eeimg="1"/>，其中 <img src="https://www.zhihu.com/equation?tex=0+%3C+%5Calpha+%3C+1" alt="0 &lt; \alpha &lt; 1" eeimg="1"/>。（这部分是动态范围过大的罪魁祸首，且压缩这部分不影响人眼对内容的感知）；</li><li data-pid="1SokBw0o">重新计算调整后的 log luminance <img src="https://www.zhihu.com/equation?tex=L%27+%3D+B%27+%2B+D+%2B+%5Cbeta" alt="L&#39; = B&#39; + D + \beta" eeimg="1"/>，其中 <img src="https://www.zhihu.com/equation?tex=%5Cbeta" alt="\beta" eeimg="1"/> 是曝光补偿常数；</li><li data-pid="k9ux9-BR">利用 <img src="https://www.zhihu.com/equation?tex=L%27" alt="L&#39;" eeimg="1"/> 计算新的图片，确保每个像素的 RGB 和原来保持比例，而 luminance 符合 <img src="https://www.zhihu.com/equation?tex=L%27" alt="L&#39;" eeimg="1"/> 的结果。</li></ol><p data-pid="Kfz0H_J-">运行 Bilateral Grid tone mapping 以后，结果终于舒服了，能同时看到高光和阴影处的结果。</p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-80d9f5d611925dc796c12c21d967dde1_b.jpg" data-size="normal" data-rawwidth="916" data-rawheight="1116" class="origin_image zh-lightbox-thumb" width="916" data-original="https://pic2.zhimg.com/v2-80d9f5d611925dc796c12c21d967dde1_r.jpg"/><figcaption>运行 bilateral_grid_hdr.py 的结果。参数还蛮多的，可以自己调一下看看每个参数会有什么效果。调不好的话容易出现光晕 (haloing)... 调节 blend 可以开关 tone mapping。图片来源：我自己拿相机在 MIT 校园里拍的。（哪天退休了真想去当一个摄影师...）</figcaption></figure><p data-pid="AfKSs55U">这部分的代码在 <a href="https://link.zhihu.com/?target=https%3A//github.com/taichi-dev/image-processing-with-taichi/blob/main/bilateral_grid_hdr.py" class=" wrap external" target="_blank" rel="nofollow noreferrer">bilateral_grid_hdr.py</a>.</p><p data-pid="n6MTAhgY">著名游戏《对马岛之魂》中就用到了双边网格进行色调映射，实现了在 PS 4 上 1080 分辨率只需要 250 us 就能完成相关处理（等我有空了一定要去玩一下这个游戏，“实地调研”一下）：</p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-158ca266c38156e048958003365f1b6d_b.jpg" data-caption="" data-size="normal" data-rawwidth="2000" data-rawheight="705" class="origin_image zh-lightbox-thumb" width="2000" data-original="https://pic2.zhimg.com/v2-158ca266c38156e048958003365f1b6d_r.jpg"/></figure><blockquote data-pid="Sn0VS_9H">图片来源：SIGGRAPH 2021 Advances in Real-Time Rendering: Real-Time Samurai Cinema: Lighting, Atmosphere, and Tonemapping in Ghost of Tsushima（YouTube 有视频，这个老哥讲得特别好，非常完整地 cover 了对马岛之魂的后处理管线的各种细节，建议有兴趣的同学观看一下。听说知乎上贴 YouTube 链接不太好，我就不放了，不过很容易搜索到。）</blockquote><h2><b>注意事项</b></h2><ul><li data-pid="NbbJY7VL"><b>存储与可视化</b>：因为一些历史原因，OpenCV 中默认的 channel 存储顺序为 BGR，这一点尤其要注意。Taichi 的可视化系统中采用 RGB 顺序。另外，OpenCV 的可视化工具 <code>imshow</code> 等将图片的左上角作为 <code>(0, 0)</code>，纵向为 i，横向为 j；而 Taichi 的 <code>gui.set_image</code> 的坐标系会将左下角作为 <code>(0, 0)</code>，横向为 i，纵向为 j。当然，如果只是用 Taichi 进行计算而不是显示，i、j 的顺序并没有这么重要，本文中也没有仔细区分。</li><li data-pid="E901ilJU"><b>调试模式</b>：在 Taichi 中，在 <code>ti.init</code> 里面打开 <code>debug=True</code> 可以进入调试模式，这时程序性能会微微下降，但是会自动检查数组越界等常见错误，大大方便调试。这一点是 CUDA 等工具不具备的。</li><li data-pid="Gf2VwSAX"><b>数据类型</b>：图片常常被 <code>np.uint8</code> 等格式保存，对应的 Taichi 格式是 <code>ti.u8</code>。类似地，<code>np.float32</code>对应 Taichi 的 <code>ti.f32</code>，或者直接使用 <code>float</code> 也行。</li><li data-pid="-9u64__F"><b>关于性能</b>：如果对于特别分辨率小的图片，使用 Taichi 在 GPU 上运算时可能并没有加速，因为 GPU kernel 的启动、Taichi 的 JIT 编译时间、以及 pybind11 的开销会抵消加速。而对于规模比较大的图片、复杂的计算，往往加速会比较明显。</li></ul><h2><b>结语</b></h2><p data-pid="uZh0oCKf">Taichi 是否可以在加速图像处理上有独特优势？答案是肯定的，我想很多读者应该也会和我一样得到相同的结论：对于 Bilateral Grid 这样的经典算法，用别的工具在 Python 中用 GPU 高效实现，是相当困难的。当然，在写作本文的过程中，我也发现了 Taichi 的很多不足之处，好在其中的大部分是比较容易在未来修复的。比如：</p><ul><li data-pid="m-dCtpCB"><code>ti.types.ndarray(element_dim=1)</code> 等 API 过长，对于用户来说需要记忆的 API 量还比较大；</li><li data-pid="kMckwTiT">在开发完原型后，用户常常有部署的需求，而这一块需要使用 Taichi 正在开发的 AOT 功能来支持；</li><li data-pid="wjfSNTEg">Pybind11 造成的调用开销对于小规模图像计算可能会导致性能下降；</li><li data-pid="BZZnBNZw">与 Matlab 等工具相比，Taichi 在一些简单而经典操作上其实并不能带来生产力的提升：高斯模糊在 Matlab、OpenCV 里也许一行代码就能实现。Taichi 的强项还是在可定制性。当然，也许这些常用操作未来也会以某种形式进入 Taichi 之中；</li><li data-pid="wSw2U_ze">还有一些报错不够响亮的问题，我直接在 GitHub 开 issue 了：<a href="https://link.zhihu.com/?target=https%3A//github.com/taichi-dev/taichi/issues/6305" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/taichi-dev/t</span><span class="invisible">aichi/issues/6305</span><span class="ellipsis"></span></a>。</li></ul><p data-pid="4feSxFyP">即使目前的 Taichi 版本在图像处理任务中还稍稍有一些不顺手的地方，我们已经能够看到 Taichi 为图像处理用户带来独特的价值。随着相关问题在开源社区得到修复，我们相信 Taichi 一定能够在这个领域大放异彩。</p><p data-pid="nNQo0iZK">本文所有代码均可以直接运行，输入图片也附在仓库内了。欢迎大家试玩：<a href="https://link.zhihu.com/?target=https%3A//github.com/taichi-dev/image-processing-with-taichi" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/taichi-dev/i</span><span class="invisible">mage-processing-with-taichi</span><span class="ellipsis"></span></a></p><p data-pid="vIEQD6UB">由于篇幅限制，本文并未对实际程序运行性能进行严谨的讨论，程序并未精心优化，也没有提及这些程序应该如何应用 Taichi AOT 部署到移动设备上。如果大家有兴趣，欢迎留言，等下次有机会的时候 (???)，我再写长文介绍！</p><p data-pid="pPt575Zx">最后，对加速 Python、图像处理感兴趣的同学，欢迎在「太极图形」微信号回复 “加群“，与社区同学一起讨论呀！</p><h2><b>参考文献与扩展阅读</b></h2><ul><li data-pid="e5E2bu9a">MIT 的双边滤波教程：<a href="https://link.zhihu.com/?target=https%3A//people.csail.mit.edu/sparis/bf_course/" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">people.csail.mit.edu/sp</span><span class="invisible">aris/bf_course/</span><span class="ellipsis"></span></a></li><li data-pid="NoEDm-7N">Bilateral Grid 原始论文: <a href="https://link.zhihu.com/?target=https%3A//people.csail.mit.edu/sparis/publi/2007/siggraph/Chen_07_Bilateral_Grid.pdf" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">people.csail.mit.edu/sp</span><span class="invisible">aris/publi/2007/siggraph/Chen_07_Bilateral_Grid.pdf</span><span class="ellipsis"></span></a></li><li data-pid="tjDBiSjm">《对马岛之魂的》实时后处理：SIGGRAPH 2021 Advances in Real-Time Rendering: Real-Time Samurai Cinema: Lighting, Atmosphere, and Tonemapping in Ghost of Tsushima</li><li data-pid="nThENFl5">知乎上的一篇很棒的双边滤波中文教程：<a href="https://zhuanlan.zhihu.com/p/365874538" class="internal"><span class="invisible">https://</span><span class="visible">zhuanlan.zhihu.com/p/36</span><span class="invisible">5874538</span><span class="ellipsis"></span></a></li><li data-pid="VP_lDCaX">Taichi 语言中文官网：<a href="https://link.zhihu.com/?target=https%3A//taichi-lang.cn/" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">taichi-lang.cn/</span><span class="invisible"></span></a></li><li data-pid="ukcz0T3P">Taichi 中文论坛：<a href="https://link.zhihu.com/?target=https%3A//forum.taichi.graphics/" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">forum.taichi.graphics/</span><span class="invisible"></span></a></li><li data-pid="cSFbXI6C">Taichi 语言文档（部分有中文翻译）：<a href="https://link.zhihu.com/?target=https%3A//docs.taichi-lang.org/" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">docs.taichi-lang.org/</span><span class="invisible"></span></a></li><li data-pid="vX7THKjx">本文中的部分图片来自 Wikipedia</li></ul><p data-pid="sefUU1qU"><i>本文作者：Yuanming &amp; Liang</i></p>
<br><br>
来源：知乎 www.zhihu.com<br>
    
作者：<a href="http://zhuanlan.zhihu.com/p/573894977?utm_campaign=rss&utm_medium=rss&utm_source=rss&utm_content=title">知乎用户（登录查看详情）</a><br>
            
<br>
【知乎日报】千万用户的选择，做朋友圈里的新鲜事分享大牛。
        <a href="http://daily.zhihu.com?utm_source=rssyanwenzi&utm_campaign=tuijian&utm_medium=rssnormal" target="_blank">点击下载</a><br>